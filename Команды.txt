У всех команд необходимо вначале писать sudo, т.к. это указывает на то, что команда запускается от администратора.

sudo docker ps - показывает список запущенных контейнеров docker. 
sudo docker ps -a - показывает список всех контейнеров docker.
sudo docker images - показывает список всех снимков п окоторым можно создать контейнеры docker.
sudo docker stop "несколько символов из ID контейнера" - завершает работу контейнера docker.
sudo docker kill "несколько символов из ID контейнера" - жестко убивает контейнер docker.
sudo docker build -t counter_webservice:v1 . - команда создания снимка docker контейнера из Dockerfile, запускается из директории, где лежит Dockerfile.
sudo docker run -d -p 82:8080 counter_webservice:v1 - команда запускает docker контейнер или создает контейнер из имеющегося image. Наличие image сначала проверяется на компьютере, если его там нет, то проверяется на Dockerhub. v1 версия image, если она не указана, то по умолчанию будет считаться, что стоит latest. -p указывает, что трафик адресованный порту 82 на компьютере будет адресован этому контейнеру, а внутри самого контейнера он будет адресован порту 8080. Это надо т.к. одни и те же службы слушают один и тот же порт, а значит, запуская два контейнера, мы должны их различать, хотя внутри каждого контейнера работает служба, которая слушает один и тот же порт.
sudo docker run -d --network=bridge -p 82:8080 counter_webservice:v1 - тоже самое, что и выше, но только цепляет контейнер к сети bridge, чтобы через нее контейнеры могли передавать данные. У bridge обычно по умолчанию ip 172.17.0.1.
sudo docker-compose up - запускается из дериктории, где есть файл docker-compose.yml. Команда создает контейнеры из images и запускает из.
sudo docker-compose down - запускается из дериктории, где есть файл docker-compose.yml. Команда завершает контейнеры, запущенные с помощью команды выше, и удаляет эти контейнеры.
sudo docker-compose start - запускается из дериктории, где есть файл docker-compose.yml. Команда работает почти как UP, но не создает контейнеры, а использует ранее созданные(требуется, чтобы контейнеры были заранее созданы).
sudo docker-compose stop - запускается из дериктории, где есть файл docker-compose.yml. Команда работает почти как DOWN, но не удаляет контейнеры после их остановки.

ab -c 1 -n 5000 -s 10000 http://localhost:81/incr - ab это Apache Benchmark утилита для тестирования веба под нагрузкой в виде генерации большого числа запросов. 
														-c concurrency количество конкурентных запросов.
														-n requests     количество запросов страницы.
														-s timeout     максимальное время на один запрос. По умолчанию 30 секунд.
														http://localhost:81/incr - сайт к которому мы обращаемся
														
														
														
Балансировка
	round-robin — используется по умолчанию. Веб сервер равномерно распределяет нагрузку на сервера с учетом их весов. Специально указывать этот метод в конфигурации не надо.
	least_conn — (least-connected) запрос отправляется к серверу с наименьшим количеством активных подключений. В конфигурации данный параметр распределения запросов устанавливается параметром least_conn.
	ip_hash — используется хэш функция, основанная на клиентском ip адресе, для определения, куда направить следующий запрос. Используется для привязки клиента к одному и тому же серверу. В предыдущих методах один и тот же клиент может попадать на разные серверы.
	hash — задаёт метод балансировки, при котором соответствие клиента серверу определяется при помощи хэшированного значения ключа. В качестве ключа может использоваться текст, переменные и их комбинации.
	random — балансировка нагрузки, при которой запрос передаётся случайно выбранному серверу, с учётом весов.
Пример настройки:
	upstream webService {
		least_conn;
		server localhost:81;
		server localhost:82;
	}
	
	weight — Задает вес сервера, по умолчанию 1. Чем больше вес сервера, тем пропорционально больше запросов он будет принимать от балансировщика.
	max_conns — Ограничивает максимальное число одновременных активных соединений к проксируемому серверу Значение по умолчанию равно 0 и означает, что ограничения нет.
	max_fails — Задаёт число неудачных попыток работы с сервером, которые должны произойти в течение времени, заданного параметром fail_timeout, чтобы сервер считался недоступным на период времени, также заданный параметром 	fail_timeout. Дефолтное значение — 1.
	fail_timeout — Задаёт время, в течение которого должно произойти заданное число неудачных попыток работы с сервером для того, чтобы сервер считался недоступным и время, в течение которого сервер будет считаться недоступным. По умолчанию параметр равен 10 секундам.
	backup — Помечает сервер как запасной сервер. На него будут передаваться запросы в случае, если не работают основные серверы.
	down — Помечает сервер как постоянно недоступный.
Пример настройки:
	upstream webService {
		least_conn;
		server localhost:81 max_fails=3 fail_timeout=2s;
		server localhost:82 max_fails=3 fail_timeout=2s;
	}
	
Настроено так, что на портах висит:
	80 - ngnix на самой виртуалке.
	81 - ngnix в docker;
	82 - webService #1 в docker;
	83 - webService #2 в docker;
	6379 - redis в docker.
	
Redis:
	redis-cli -h localhost - Подключение к Redis в Docker.
	keys * - список всех ключей, которые есть в Redis.
	get "ключ" - получаем значение ключа.
	set "ключ" - задаем значение ключу.

Redis:
«ключ-значение»
	• Самая простая операция – это установка
	строкового значения по ключу и чтение:
		127.0.0.1:6379> EXISTS foo
		(integer) 0
		127.0.0.1:6379> SET foo "Hello!"
		OK
		127.0.0.1:6379> GET foo
		"Hello!"
		127.0.0.1:6379> EXISTS foo
		(integer) 1
	• Чуть сложнее вариант с установкой срока
	жизни значения в секундах или
	миллисекундах:
		127.0.0.1:6379> SET foo "Hello!" EX 5
		OK
		127.0.0.1:6379> GET foo
		"Hello!"
		127.0.0.1:6379> GET foo
		(nil)
	• Установка нового значения с возвращением
	старого:
		127.0.0.1:6379> SET foo "Hello!"
		OK
		127.0.0.1:6379> GETSET foo "World"
		"Hello!"
		127.0.0.1:6379> GET foo
		"World"
	• Добавление к значению строки:
		127.0.0.1:6379> SET foo "Hello"
		OK
		127.0.0.1:6379> APPEND foo " World"
		(integer) 11
		127.0.0.1:6379> GET foo
		"Hello World"
	• Инкремент и декремент (счетчики)
		127.0.0.1:6379> SET foo 1
		OK
		127.0.0.1:6379> INCR foo
		(integer) 2
		127.0.0.1:6379> GET foo
		"2"
		127.0.0.1:6379> DECR foo
		(integer) 1
		127.0.0.1:6379> GET foo
		"1"		
Redis:
«Хэш-таблицы»
	• Хэш-таблицу можно представлять себе как
	объект, состоящий из полей. Каждое поле
	имеет своё имя и значение.
	• Другое название – «ассоциативный массив»
		127.0.0.1:6379> HSET obj foo 42
		(integer) 1
		127.0.0.1:6379> HGET obj foo
		"42"
		127.0.0.1:6379> HSET obj bar 24
		(integer) 1
		127.0.0.1:6379> HGETALL obj
		1) "foo"
		2) "42"
		3) "bar"
		4) "24"
		127.0.0.1:6379> HVALS obj
		1) "42"
		2) "24"	
Redis:
«Множество»
	• Множество – это неупорядоченный набор
	значений.
		127.0.0.1:6379> SADD myset "Hello"
		(integer) 1
		127.0.0.1:6379> SADD myset "World"
		(integer) 1
		127.0.0.1:6379> SMEMBERS myset
		1) "World"
		2) "Hello"
		127.0.0.1:6379> SCARD myset
		(integer) 2
	SISMEMBER, SUNION,
	SDIFF, SINTER,
	SREM, SPOP, SMOVE	
Redis:
«Списки»
	• Список – это последовательность значений,
	упорядоченных по порядку их создания.
		127.0.0.1:6379> LPUSH mylist "first"
		(integer) 1
		127.0.0.1:6379> LPUSH mylist "second"
		(integer) 2
		127.0.0.1:6379> LPOP mylist
		"second”
		127.0.0.1:6379>
		LINSERT mylist BEFORE first "zero"
		(integer) 2
		127.0.0.1:6379> LRANGE mylist 0 -1
		1) "zero"
		2) "first"	
Redis:
«Упорядоченные множества»
	• А еще есть упорядоченные множества. Это как
	множество, но вы можете задать порядок J
		127.0.0.1:6379> ZADD myzset 2 "one"
		(integer) 1
		127.0.0.1:6379> ZADD myzset 1 "two"
		(integer) 1
		127.0.0.1:6379>
		ZRANGE myzset 0 -1 WITHSCORES
		1) "two"
		2) "1"
		3) "one"
		4) "2"		
Redis:
«Транзакции»
	• Транзакция: множество команд,
	выполняющихся, как одна команда.
		127.0.0.1:6379> MULTI
		OK
		127.0.0.1:6379> INCR foo
		QUEUED
		127.0.0.1:6379> INCR bar
		QUEUED
		127.0.0.1:6379> EXEC
		1) (integer) 3
		2) (integer) 1
	Команда DISCARD прерывает набор команд в
	транзакцию.
	N. B. Важно понимать, что в Redis нет отката!
	Сбой одной из команд в «транзакции» не
	приводит к отмене предыдущих, вместо этого
	выполняются все следующие L	
Redis:
«Подписки»
Механизм подписок в Redis устроен очень
просто.
	• Одни клиенты сервиса Redis подписываются
	на определенные каналы сообщений:
		127.0.0.1:6379> SUBSCRIBE channel1
		Reading messages... (press Ctrl-C to
		quit)
		1) "subscribe"
		2) "channel1"
		3) (integer) 1
	• Другие клиенты могут посылать сообщения в
	каналы. Подписанные на данные каналы
	клиенты получат сообщения:
		127.0.0.1:6379>
		PUBLISH channel1 "Hello!"
		(integer) 1
		...
		3) "Hello!"		
	
	
	
	
	
	
	
	
	
	sudo gedit /etc/nginx/nginx.conf